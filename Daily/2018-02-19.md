## 오늘 푼 알고리즘 문제
- 소수구하기 문제
	- 소수구하기는 그냥 생각하면 일일히 i 미만의 수 중, 어떤 수로 나누어지면 소수라고 생각할 수 있다.
	- 그러나 이렇게 구하면 시간복잡도가 굉장히 늘어난다.
	- 소수구하기 최적화 알고리즘 중 가장 유명한 알고리즘은 에라토스테네스의 체 라는 알고리즘이다.
	- 이 알고리즘은 2 부터 n까지를 돌면서 자신의 배수를 모두 체크한다.
	- 이렇게 모든 수가 체크되면 결국 남은 체크 안된 수가 소수라고 할 수 있다. 어떤수의 배수도 아니기 때문이다.
	- 에라토스테네스의 체의 시간복잡도를 생각 해 보면 일단 n만큼은 다 도는데, 2의 배수를 찾으면서 절반이 사라지고, 3의 배수를 찾으면서 거의 모든 배수가 체크된다고 보면 될 것 같다. 증명은 잘 모르겠지만 nloglogn이라고 한다. nlogn보다 빠른 시간복잡도를 가진 알고리즘이고, 구해두기만 한다면 어떤 수가 소수인지 아닌지는 O(1)만에 알 수 있다.

- table decorations
	- 이 문제는 아직도 이해가 잘 안간다.
	- r, g ,b 색의 풍선 개수가 각각 주어지고, 각 테이블은 풍선 3개로 장식된다.
	- 3개의 풍선은 모두 같은 색이 될 수 없다.
	- 이때 최대한 많은 테이블을 꾸민다고 하면 그 개수를 출력해야 한다.
	- 처음에는 r g b 중 가장 작은 개수로 rgb 모두 있는 테이블을 만들고, rgg, gbb 등등의 조합을 만들면서 하면 될 것 같았다.
	- 그래서 r g b를 sort 하고, 작은 개수를 처리하고, 중간, 큰 수를 조합하게 했는데, 뭔가가 꼬여서 지금 풀이가 생각이 안난다.

### KMP
문자열 관련 알고리즘 중 kmp라는 알고리즘이 존재한다. k m p는 각각 어떤 사람의 이름의 첫 이니셜이고, 다른 뜻은 존재하지 않는다.

어떤 알고리즘이냐면 일단 우리가 어떤 문자열 s에 대해 subStrPattern이 있는지 검사한다고 생각 해 보자.

무식하게 계산한다면 i = 0부터 차례차례 검사 해 나가면서 얘가 있는지~ 없는지 판단할 것 이다.

문자열 길이가 n이고, substr 길이가 m라고 할 때, for문을 n - m + 1 번 돌면서 k번 체크해야 하므로 m(n - m + 1)번 for문을 돌면서 체크하게 될 것이다. 따라서 O(mn) 시간 복잡도가 나올 것 같다.

하지만 kmp는 이 복잡도를 O(n + m)으로 줄여준다고 한다.

기본적인 개념은, 내가 어떤 문자열 s가 있고 그 s에 대해 subStrPattern p를 찾는다고 하면, 하나하나 도는 것이 아니고, 만약 불일치하는 곳이 있다면 이전에 일치하는 부분을 기록해두고, 그 부분으로 점프해서 검색해 나간다는 아이디어이다.

즉 핵심은 "Prefix, suffix를 이용해서 점프할 수 있는 구간은 점프한다"이다.

뭔가 개념적으로는 이해가 가는 듯 한데, 막상 구현을 보면 아직 이해가 안된다. 조금더 이해가 필요하고, 이걸 이해한 다음 펠린드롬을 이해하고 문제를 풀어봐야겠다.

### 알고리즘에 대한 생각
항상 모든 알고리즘은 "무식한 방법으로 하나하나 하는것"보다 나는 방법을 제시하기 위해 나온것 같다.

예를들어 sorting도 버블소팅으로 시작해서 둘로 쪼개고, pivot을 잡고 하는 과정으로 sorting 속도를 높혀간다.

문자열 검색도 단어를 하나하나 넘겨가면서 검사하는 것 보다는 prefix suffix를 찾아가면서 점프하면서 검사를 최대한 덜 하도록 한다.

알고리즘 문제를 접근하는 방식도 나는 현재 이렇게 풀고있는 것 같다. 알고리즘을 아직 다 숙달하지 못한 사람으로써, 일단 먼저 문제를 단순하게 하나하나 처리하는 방법으로 접근하고, 그 다음에 아 이게 sorting이 필요하겠구나, 어떤 탐색이 필요하겠구나를 판단 하고 그것을 적용시켜나가는 것 같다.

그리고 그 판단이 안서면 내가 모르는 것이고, 그건  이론을 찾아서 익히고, 구현을 보면서 따라해보고, 문제 몇가지를 풀면 내것이 되는 것 같다. 그리고 이것들이 쌓여서 어떤 문제를 만나면 "아 이건 이런 시간을 줄여야하고 그러려면 이런 알고리즘이 필요하다" 라는 판단이 가능하게 되는 것 같다.

일단 kmp를 다시 이해하고 그 다음 펠린드롬으로 간다! 이정도 하면 문자열 탐색 관련 알고리즘은 초급 수준은 해결되는 느낌이다.